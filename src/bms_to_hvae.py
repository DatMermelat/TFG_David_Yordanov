from argparse import ArgumentParser

import os
import re
import torch

from model import HVAE
from hvae_utils import tokens_to_tree, create_batch, load_config_file
from symbol_library import generate_symbol_library
from tree import Node

class BmsReader:

  def __init__(self):
    pass

  def extract_expressions(self, file_path):
    """
    Extracts only the mathematical expressions from the BMS dataset file.
    """
    with open(file_path, 'r') as file:
      expressions = []
      lines = file.readlines()
      for line in lines:
        expression = line.strip().split("||")[2]
        expressions.append(expression)
    return expressions


class ReconstructionExperiment:

  def __init__(self, model, expressions: list, hvae_symbols: dict):
    self.model = model
    self.expressions = expressions
    self.symbols = hvae_symbols
    self.results = {}
    self.total_tries = 0
    self.total_succesful = 0

  def save_result(self, expression: str, is_successful: bool):
    """
    Saves the result of the experiment.
    """
    if expression not in self.results:
      self.results[expression] = {"tries": 1, "n_successful": 1 if is_successful else 0}
    else:
      self.results[expression]["tries"] += 1
      if is_successful:
        self.results[expression]["n_successful"] += 1

  def run(self):
    """
    Experiment consisting of encoding expressions generated by
    BMS into the HVAE latent space and then decoding them back.
    """
    for expression in self.expressions:
      tokens = expression.split()
      if all(token in (list(self.symbols.keys()) + ["(",")"]) for token in tokens):
        tree = tokens_to_tree(tokens, self.symbols)

        # Encoding and decoding tree
        batch = create_batch([tree])
        vector = self.model.encode(batch)[0]
        decoded_expression = str(self.model.decode(vector)[0])
        self.total_tries += 1

        # Check if successful
        if decoded_expression == expression:
          self.save_result(expression, is_successful=True)
        else:
          self.save_result(expression, is_successful=False)

  def to_txt(self, path: str):
    with open(path, 'w') as file:
      file.write("success_rate: " + str(self.total_succesful / self.total_tries) + "\n")
      for expr, result in self.results.items():
        file.write(f"{expr} || {result['tries']} || {result['n_successful']/result['tries']}\n")


def get_symbols(expressions: list):
  """
  Returns the set of unique symbols appearing in the expressions.
  INPUT: list of expression strings
  OUTPUT: set of unique symbols (ignoring parentheses)
  """
  symbols = set()
  for expression in expressions:
    tokens = expression.translate(str.maketrans({"(": " ", ")": " "})).split()
    for token in tokens:
      if token not in symbols:
        symbols.add(token)
  return symbols


def create_symbol_mapping(symbols: set):
  """
  Returns a mapping of BMS symbols to HVAE notation.
  """
  symbol_mapping = {}
  for symbol in symbols:
    if symbol == "x":
      symbol_mapping[symbol] = "X"

    elif symbol == "**":
      symbol_mapping[symbol] = "^"

    elif symbol.startswith("pow"):
      symbol_mapping[symbol] = "^" + symbol[-1]

    elif symbol.startswith("_"):
      symbol_mapping[symbol] = "C"
  return symbol_mapping


def add_whitespaces(expression: str):
  """
  Adds whitespaces around every token in the expression.
  """
  aux = expression.translate(str.maketrans({"(": " ( ", ")": " ) "}))
  ws_expr = re.sub(r'\s+', ' ', aux).strip()
  return ws_expr


def convert_to_hvae(expressions: list, symbol_mapping: dict):
  """
  Converts BMS expressions to HVAE notation.
  INPUT: list of expression strings in BMS notation
  OUTPUT: list of expression strings in HVAE notation
  """
  converted = []

  for expression in expressions:
      ws_expression = add_whitespaces(expression)
      tokens = ws_expression.split()

      for i, token in enumerate(tokens):
        if token in symbol_mapping:
          tokens[i] = symbol_mapping[token]

        elif token == "-":
          del tokens[i]

      # Converting tokens back to string
      expression = " ".join(tokens)
      converted.append(expression)
  return converted


if __name__ == '__main__':
  parser = ArgumentParser(prog='BMS reconstruction', description='Ecoding and decoding of BMS generated expressions')
  parser.add_argument("-config", default="../configs/test_config.json")

  args = parser.parse_args()

  config = load_config_file(args.config)
  expr_config = config["expression_definition"]
  es_config = config["expression_set_generation"]
  training_config = config["training"]
  sy_lib = generate_symbol_library(expr_config["num_variables"], expr_config["symbols"], expr_config["has_constants"])
  so = {s["symbol"]: s for s in sy_lib}
  HVAE.add_symbols(sy_lib)

  model = torch.load(training_config["param_path"], weights_only=False)

  bms_dataset_filename = "BMS_log(x+1.4) + log(x__2 + 1.3).txt"
  path = "../seeslab/BMS"
  bms_dataset_path = os.path.join(path, bms_dataset_filename)
  reader = BmsReader()

  expressions = reader.extract_expressions(bms_dataset_path)
  symbols = get_symbols(expressions)
  symbol_mapping = create_symbol_mapping(symbols)
  hvae_expressions = convert_to_hvae(expressions, symbol_mapping)

  experiment = ReconstructionExperiment(model, hvae_expressions, so)
  experiment.run()
  experiment.to_txt(os.path.join(path, "results.txt"))
